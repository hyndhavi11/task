# -*- coding: utf-8 -*-
"""task.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YOVF-ahFC0G9B2spsIkT2gUfx9ihJdHz
"""

import pandas as pd
import numpy as np

# Load dataset
df = pd.read_csv('/content/TRADES_CopyTr_90D_ROI.csv')

# Data cleaning (handle missing values, correct data types)
df = df.dropna()  # or use fillna, depending on context

# Feature engineering (identifying positions, win positions, etc.)
def classify_position(row):
    # This function needs to have some logic to classify positions based on 'row'
    # For now, it just returns 0 - replace this with your actual logic
    return 0

# Apply the function to create the 'position' column
df['position'] = df.apply(lambda row: classify_position(row), axis=1)
df['win_position'] = df['realizedProfit'].apply(lambda x: 1 if x > 0 else 0)

# Group by accounts to calculate metrics
grouped = df.groupby('Port_IDs')

# Calculating metrics
# Define helper functions (calculate_roi, calculate_sharpe_ratio, calculate_mdd)
def calculate_roi(df):
    # ROI = (final value - initial value) / initial value * 100
    initial_value = df['price'].iloc[0] * df['quantity'].iloc[0]
    final_value = df['price'].iloc[-1] * df['quantity'].iloc[-1]
    return (final_value - initial_value) / initial_value * 100

def calculate_sharpe_ratio(df, risk_free_rate=0):
    daily_returns = df['price'].pct_change().dropna()
    mean_return = daily_returns.mean()
    return_std = daily_returns.std()
    sharpe_ratio = (mean_return - risk_free_rate) / return_std if return_std != 0 else np.nan
    return sharpe_ratio

def calculate_mdd(df):
    cumulative_returns = (1 + df['price'].pct_change().dropna()).cumprod()
    drawdown = cumulative_returns.cummax() - cumulative_returns
    max_drawdown = drawdown.max() / cumulative_returns.cummax().max() * 100
    return max_drawdown

# Removed the custom agg function and directly used grouped.agg
metrics_pos = grouped.agg(
    total_positions=('position', 'count'),
    win_positions=('win_position', 'sum'),
    total_pnl=('realizedProfit', 'sum'),
    roi=('price', lambda x: calculate_roi(x)),
    sharpe_ratio=('price', lambda x: calculate_sharpe_ratio(x)),
    max_drawdown=('price', lambda x: calculate_mdd(x))
)

# Calculate win rate
metrics_pos['win_rate'] = metrics_pos['win_positions'] / metrics_pos['total_positions'] * 100

# Ranking system (applying weights and ranking)
weights = {'roi': 0.4, 'sharpe_ratio': 0.3, 'total_pnl': 0.15, 'max_drawdown': 0.1, 'win_rate': 0.05}
metrics_pos['score'] = (
    metrics_pos['roi'] * weights['roi'] +
    metrics_pos['sharpe_ratio'] * weights['sharpe_ratio'] +
    metrics_pos['total_pnl'] * weights['total_pnl'] +
    metrics_pos['max_drawdown'] * weights['max_drawdown'] +
    metrics_pos['win_rate'] * weights['win_rate']
)

# Rank the accounts
metrics_pos['rank'] = metrics_pos['score'].rank(ascending=False)

# Get top 20 accounts
top_20_accounts = metrics_pos.sort_values(by='score', ascending=False).head(20)

# Save results
top_20_accounts